"use strict";
/**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/metaplex-foundation/kinobi
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExactOutAmountNotMatchedError = exports.SwapNotSupportedError = exports.TokenProgramNotProvidedError = exports.IncorrectTokenProgramIDError = exports.InvalidTokenLedgerError = exports.LedgerTokenAccountDoesNotMatchError = exports.InvalidReferralAuthorityError = exports.InvalidRoutePlanError = exports.NonZeroMinimumOutAmountNotSupportedError = exports.NotEnoughAccountKeysError = exports.InvalidOutputIndexError = exports.InvalidInputIndexError = exports.NotEnoughPercentError = exports.InvalidSlippageError = exports.MissingPlatformFeeAccountError = exports.InvalidCalculationError = exports.SlippageToleranceExceededError = exports.EmptyRouteError = void 0;
exports.getJupiterErrorFromCode = getJupiterErrorFromCode;
exports.getJupiterErrorFromName = getJupiterErrorFromName;
const umi_1 = require("@metaplex-foundation/umi");
const codeToErrorMap = new Map();
const nameToErrorMap = new Map();
/** EmptyRoute: Empty route */
class EmptyRouteError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Empty route', program, cause);
        this.name = 'EmptyRoute';
        this.code = 0x1770; // 6000
    }
}
exports.EmptyRouteError = EmptyRouteError;
codeToErrorMap.set(0x1770, EmptyRouteError);
nameToErrorMap.set('EmptyRoute', EmptyRouteError);
/** SlippageToleranceExceeded: Slippage tolerance exceeded */
class SlippageToleranceExceededError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Slippage tolerance exceeded', program, cause);
        this.name = 'SlippageToleranceExceeded';
        this.code = 0x1771; // 6001
    }
}
exports.SlippageToleranceExceededError = SlippageToleranceExceededError;
codeToErrorMap.set(0x1771, SlippageToleranceExceededError);
nameToErrorMap.set('SlippageToleranceExceeded', SlippageToleranceExceededError);
/** InvalidCalculation: Invalid calculation */
class InvalidCalculationError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid calculation', program, cause);
        this.name = 'InvalidCalculation';
        this.code = 0x1772; // 6002
    }
}
exports.InvalidCalculationError = InvalidCalculationError;
codeToErrorMap.set(0x1772, InvalidCalculationError);
nameToErrorMap.set('InvalidCalculation', InvalidCalculationError);
/** MissingPlatformFeeAccount: Missing platform fee account */
class MissingPlatformFeeAccountError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Missing platform fee account', program, cause);
        this.name = 'MissingPlatformFeeAccount';
        this.code = 0x1773; // 6003
    }
}
exports.MissingPlatformFeeAccountError = MissingPlatformFeeAccountError;
codeToErrorMap.set(0x1773, MissingPlatformFeeAccountError);
nameToErrorMap.set('MissingPlatformFeeAccount', MissingPlatformFeeAccountError);
/** InvalidSlippage: Invalid slippage */
class InvalidSlippageError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid slippage', program, cause);
        this.name = 'InvalidSlippage';
        this.code = 0x1774; // 6004
    }
}
exports.InvalidSlippageError = InvalidSlippageError;
codeToErrorMap.set(0x1774, InvalidSlippageError);
nameToErrorMap.set('InvalidSlippage', InvalidSlippageError);
/** NotEnoughPercent: Not enough percent to 100 */
class NotEnoughPercentError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Not enough percent to 100', program, cause);
        this.name = 'NotEnoughPercent';
        this.code = 0x1775; // 6005
    }
}
exports.NotEnoughPercentError = NotEnoughPercentError;
codeToErrorMap.set(0x1775, NotEnoughPercentError);
nameToErrorMap.set('NotEnoughPercent', NotEnoughPercentError);
/** InvalidInputIndex: Token input index is invalid */
class InvalidInputIndexError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Token input index is invalid', program, cause);
        this.name = 'InvalidInputIndex';
        this.code = 0x1776; // 6006
    }
}
exports.InvalidInputIndexError = InvalidInputIndexError;
codeToErrorMap.set(0x1776, InvalidInputIndexError);
nameToErrorMap.set('InvalidInputIndex', InvalidInputIndexError);
/** InvalidOutputIndex: Token output index is invalid */
class InvalidOutputIndexError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Token output index is invalid', program, cause);
        this.name = 'InvalidOutputIndex';
        this.code = 0x1777; // 6007
    }
}
exports.InvalidOutputIndexError = InvalidOutputIndexError;
codeToErrorMap.set(0x1777, InvalidOutputIndexError);
nameToErrorMap.set('InvalidOutputIndex', InvalidOutputIndexError);
/** NotEnoughAccountKeys: Not Enough Account keys */
class NotEnoughAccountKeysError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Not Enough Account keys', program, cause);
        this.name = 'NotEnoughAccountKeys';
        this.code = 0x1778; // 6008
    }
}
exports.NotEnoughAccountKeysError = NotEnoughAccountKeysError;
codeToErrorMap.set(0x1778, NotEnoughAccountKeysError);
nameToErrorMap.set('NotEnoughAccountKeys', NotEnoughAccountKeysError);
/** NonZeroMinimumOutAmountNotSupported: Non zero minimum out amount not supported */
class NonZeroMinimumOutAmountNotSupportedError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Non zero minimum out amount not supported', program, cause);
        this.name = 'NonZeroMinimumOutAmountNotSupported';
        this.code = 0x1779; // 6009
    }
}
exports.NonZeroMinimumOutAmountNotSupportedError = NonZeroMinimumOutAmountNotSupportedError;
codeToErrorMap.set(0x1779, NonZeroMinimumOutAmountNotSupportedError);
nameToErrorMap.set('NonZeroMinimumOutAmountNotSupported', NonZeroMinimumOutAmountNotSupportedError);
/** InvalidRoutePlan: Invalid route plan */
class InvalidRoutePlanError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid route plan', program, cause);
        this.name = 'InvalidRoutePlan';
        this.code = 0x177a; // 6010
    }
}
exports.InvalidRoutePlanError = InvalidRoutePlanError;
codeToErrorMap.set(0x177a, InvalidRoutePlanError);
nameToErrorMap.set('InvalidRoutePlan', InvalidRoutePlanError);
/** InvalidReferralAuthority: Invalid referral authority */
class InvalidReferralAuthorityError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid referral authority', program, cause);
        this.name = 'InvalidReferralAuthority';
        this.code = 0x177b; // 6011
    }
}
exports.InvalidReferralAuthorityError = InvalidReferralAuthorityError;
codeToErrorMap.set(0x177b, InvalidReferralAuthorityError);
nameToErrorMap.set('InvalidReferralAuthority', InvalidReferralAuthorityError);
/** LedgerTokenAccountDoesNotMatch: Token account doesn't match the ledger */
class LedgerTokenAccountDoesNotMatchError extends umi_1.ProgramError {
    constructor(program, cause) {
        super("Token account doesn't match the ledger", program, cause);
        this.name = 'LedgerTokenAccountDoesNotMatch';
        this.code = 0x177c; // 6012
    }
}
exports.LedgerTokenAccountDoesNotMatchError = LedgerTokenAccountDoesNotMatchError;
codeToErrorMap.set(0x177c, LedgerTokenAccountDoesNotMatchError);
nameToErrorMap.set('LedgerTokenAccountDoesNotMatch', LedgerTokenAccountDoesNotMatchError);
/** InvalidTokenLedger: Invalid token ledger */
class InvalidTokenLedgerError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid token ledger', program, cause);
        this.name = 'InvalidTokenLedger';
        this.code = 0x177d; // 6013
    }
}
exports.InvalidTokenLedgerError = InvalidTokenLedgerError;
codeToErrorMap.set(0x177d, InvalidTokenLedgerError);
nameToErrorMap.set('InvalidTokenLedger', InvalidTokenLedgerError);
/** IncorrectTokenProgramID: Token program ID is invalid */
class IncorrectTokenProgramIDError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Token program ID is invalid', program, cause);
        this.name = 'IncorrectTokenProgramID';
        this.code = 0x177e; // 6014
    }
}
exports.IncorrectTokenProgramIDError = IncorrectTokenProgramIDError;
codeToErrorMap.set(0x177e, IncorrectTokenProgramIDError);
nameToErrorMap.set('IncorrectTokenProgramID', IncorrectTokenProgramIDError);
/** TokenProgramNotProvided: Token program not provided */
class TokenProgramNotProvidedError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Token program not provided', program, cause);
        this.name = 'TokenProgramNotProvided';
        this.code = 0x177f; // 6015
    }
}
exports.TokenProgramNotProvidedError = TokenProgramNotProvidedError;
codeToErrorMap.set(0x177f, TokenProgramNotProvidedError);
nameToErrorMap.set('TokenProgramNotProvided', TokenProgramNotProvidedError);
/** SwapNotSupported: Swap not supported */
class SwapNotSupportedError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Swap not supported', program, cause);
        this.name = 'SwapNotSupported';
        this.code = 0x1780; // 6016
    }
}
exports.SwapNotSupportedError = SwapNotSupportedError;
codeToErrorMap.set(0x1780, SwapNotSupportedError);
nameToErrorMap.set('SwapNotSupported', SwapNotSupportedError);
/** ExactOutAmountNotMatched: Exact out amount doesn't match */
class ExactOutAmountNotMatchedError extends umi_1.ProgramError {
    constructor(program, cause) {
        super("Exact out amount doesn't match", program, cause);
        this.name = 'ExactOutAmountNotMatched';
        this.code = 0x1781; // 6017
    }
}
exports.ExactOutAmountNotMatchedError = ExactOutAmountNotMatchedError;
codeToErrorMap.set(0x1781, ExactOutAmountNotMatchedError);
nameToErrorMap.set('ExactOutAmountNotMatched', ExactOutAmountNotMatchedError);
/**
 * Attempts to resolve a custom program error from the provided error code.
 * @category Errors
 */
function getJupiterErrorFromCode(code, program, cause) {
    const constructor = codeToErrorMap.get(code);
    return constructor ? new constructor(program, cause) : null;
}
/**
 * Attempts to resolve a custom program error from the provided error name, i.e. 'Unauthorized'.
 * @category Errors
 */
function getJupiterErrorFromName(name, program, cause) {
    const constructor = nameToErrorMap.get(name);
    return constructor ? new constructor(program, cause) : null;
}
